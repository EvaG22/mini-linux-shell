Ευαγγελία Γούλα - sdi2000040

Για να τρέξει το πρόγραμμα:
make
./mysh

Ο κώδικας λειτουργει ως εξής: Διαβάζεται το κάθε command Που δίνει ο χρήστης και καταγράφεται στην λίστα history.
Από την main καλείται η tokenize_input προκειμενου να γινει το parsing και μετά η execute_command,
στην οποία γίνονται όλοι οι έλεγχοι για τα διάφορα είση εντολών. Πρωτού καλεστει η execute_command,
γίνεται ένας έλεγχος μέσα στην main ώστε να ελεγχθεί αν πρόκειται για εντολή με pipe. Σε αυτήν την περίπτωση,
καλείται η execute_piped_command και δεν μπαίνει στην execute_command. Τωρα στην execute_command, ελέγχω το τι 
είδους εντολή δώθηκε με strcmp και αναλόγως καλείται η αντίστοιχη συνάρτηση, για παράδειγμα μία εντολή 
με redirection πχ sort file1 >> file3 θα καλέσει την handle_redirection. Περεταίρω σχόλια για το πώς λειτουργει
η κάθε συνάρτηση ξεχωριστά βρίσκονται σαν σχόλια μέσα στον κώδικα. Ελπίζω να είναι σχετικά ευανάγνωστος ή εστω
με τα σχόλια και τις σημειώσεις που ακολουθούν να γίνεται κατανοητό τι προσπαθώ να κάνω.


Σε κάποιες από τις εντολές που δοκίμασα και όπως θα διαπιστώσετε και εσείς, η εντολη εκτελείται κανονικά, ωστοσο
το shell πετάει το μήνυμα No such file or directory.
Αυτό γίνεται κυρίως σε εντολές με pipes, όπως cat file1 file2 file3 | sort >> file4. Προσπάθησα 
να καταλάβω γιατί εκτελείται λάθος, εκτυπώνοντας το error code μέσω της errno, ωστόσο δεν έβγαλα άκρη, καθώς ο κωδικός 
που εκτυπώνεται είναι 0. 
Σημείωση για την redirection. Η εντολη sort τρεχει για παραδειγμα sort file1 > file2, δηλαδη οχι sort < file1 > file2. Με την
δεύτερη εκδοχή δημιουργεί μόνο το file. 

Στην εκτέλεση εντολών στο background δινεται το παράδειγμα sort file1 &; ls &; στην εκφώνηση. 
Υποθέτω εξεταζόμαστε σε εντολές όπως ls & ή οπως cat file1 & (το ";" δηλαδη δεν κατανοώ). Συγκεκριμένα, όταν δοθεί
μια τέτοια εντολή, αναμένεται στη συνέχεια ο χρήστης να δώσει την επόμενη εντολή που επιθυμεί ώστε 
να εκτελεστεί και αυτή. 

Στα wild characters εκτελούνται εντολές όπως ls gene*. 
Σημείωση: βγάζει και εδω το error message που αναφέρω στο redirection, ενώ η εντολη παλι εκτελείται κανονικά.

Τώρα στα aliases. Έχω φτιάξει μία δομη που περιέχει το όνομα, πχ για την εντολή createalias lll "ls -las", το όνομα
είναι το lll και το value, όπου στην εντολή αυτη είναι το ls -las. Προκειμένου να γίνει create, καλείται πρώτα η 
extract_quoted_string ωστε να πάρουμε το value και μετα η create_alias με ορίσματα το ονομα (tokens[1]) και το value.
Για να γίνει execution μπαινει στη συνθηκη else if (num_tokens == 1) πχ lll, με την get_alias_command ψάχνει αν 
πρόκειται για καταχωρημένο alias, και αν ναι, το εκτελει στην execute_alias_command.

Στα signals, δεν μπορεσα να υπολοιησω το control-Z ώστε να μην τερματίζει το shell. Το καλύτερο που μπόρεσα είναι 
να τερματίζει τη διαδικασία και μετά ο μόνος τρόπος να επιστρέψουμε στο in-mysh-now:> ειναι αν δώσουμε CTRL-C, το οποίο
θα ήταν νομίζω εξίσου λάθος.

Στο history, εκτυπώνονται οι εντολές που έχουν δωθεί, μαζι με νουμερο 1-20 που τους αντιστοιχεί.
Όταν ο πίνακας γεμίζει, γίνεται shift προκειμένου να αποθηκευτεί η νέα εντολή, διαγράφοντας την παλαιότερη.
